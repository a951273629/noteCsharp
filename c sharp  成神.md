c sharp  成神

## 基础篇

### `out`、`ref` 和 `params`参数

在 C# 中，`out`、`ref` 和 `params` 是用于传递参数的关键字，它们分别具有以下作用:

1. `out` 参数：将值返回给调用者，可以在方法内部修改该参数的值，但不能在方法外部修改该参数的值。使用 `out` 参数可以使方法更高效，因为方法内部可以直接修改参数的值，而不必返回一个新的值。
2. `ref` 参数：将值传递给调用者，可以在方法内部修改该参数的值，可以在方法外部修改该参数的值。与 `out` 参数不同的是，`ref` 参数会将修改的结果返回给调用者，因此使用 `ref` 参数可以提高性能，因为方法内部可以直接修改参数的值，不必返回一个新的值。
3. `params` 参数：用于指定一组参数，这些参数可以是任意类型，且可以包含重复的参数。使用 `params` 参数可以使方法更简短，更易于阅读和维护，因为它允许在方法内部使用同名参数。当使用 `params` 参数时，每个参数必须以逗号分隔。



params参数代码示例

```c#
// 定义 params 关键字修饰的参数列表  
public void PrintNumbers(int a, params int[] b)  
{
    Console.WriteLine("a = " + a);  
    for (int i = 0; i < b.Length; i++)  
    {  
        Console.WriteLine("b[" + i + "] = " + b[i]);  
    }  
}

// 调用 params 关键字修饰的参数列表  
PrintNumbers(1, 2, 3, 4, 5);  
```

需要注意的是，`out`、`ref` 和 `params` 参数只能在方法内部使用，不能在类、结构或接口等公共类型中使用。

### socket协议

Socket 是一种应用程序编程接口 (API),它允许应用程序在计算机之间进行网络通信。Socket 协议是网络通信中最广泛使用的协议之一，它被广泛用于客户端和服务器之间的通信。

Socket 协议采用客户端/服务器模型进行通信。在客户端/服务器模型中,有一个客户端和一个服务器,客户端发送请求,服务器接收请求并返回响应。客户端和服务器之间的通信使用套接字(socket)进行。

套接字是一个唯一的标识符，用于标识客户端或服务器的网络连接。客户端使用套接字连接到服务器，服务器使用套接字接收来自客户端的请求。通过套接字，客户端和服务器可以交换数据包，这些数据包可以包含任何类型的数据，如文本、图像、音频或视频。

Socket 协议支持多种通信模式，包括数据传输模式、面向连接模式和无连接模式。

数据传输模式是指客户端和服务器之间的通信是基于数据包的，数据包可以随机发送和接收。

连接模式是指客户端和服务器之间建立连接，在进行通信之前必须建立连接，通信结束后连接自动关闭。

无连接模式是指客户端和服务器之间不建立连接，数据包随机发送和接收。

Socket 协议的数据传输采用数据包的形式进行。数据包由头部和数据部分组成。头部包含数据包的标识、长度、类型等信息，用于指导服务器正确解析数据包。数据部分包含实际数据，用于传输数据。

Socket 协议的头部格式如下:

```html
Copy code<头部长度>          =<头部长度字节数>  
<头部标识>         =<头部标识符>  
<头部类型>         =<头部类型码>  
<数据长度>        =<数据长度字节数>  
<数据部分>       =<数据部分字节数>  
<数据部分>       =<实际数据部分>  
```

Socket 协议的三种模式有不同的头部格式:

- 数据传输模式：头部长度为 1，头部标识为 0，头部类型为 0，数据长度为 0，数据部分为 0。
- 面向连接模式：头部长度为 2，头部标识为 1，头部类型为 1，数据长度为 0，数据部分为协议数据部分。
- 无连接模式：头部长度为 2，头部标识为 1，头部类型为 1，数据长度为 0，数据部分为协议数据部分。

Socket 协议采用 TCP(传输控制协议) 或 UDP(用户数据报协议) 进行数据传输。TCP 协议提供可靠的数据传输，确保数据的完整性和正确性，而 UDP 协议则不提供可靠的数据传输，因此 UDP 协议通常用于数据量较小且对数据传输可靠性要求不高的应用场景。

### c sharp静态和非静态的对象

1. 静态变量和成员：静态变量和成员是在类中被定义的，而不是在对象中被定义的。它们属于类，而不是对象，并且可以在类的不同对象之间共享。静态变量和成员在类加载时就被初始化，并且始终在内存中保留。
2. 非静态变量和成员：非静态变量和成员是在对象中被定义的，它们属于对象，并且只能在对象中被访问。非静态变量和成员在创建对象时就被初始化，并且对象死亡时，它们会被自动销毁。

总结：

- 静态函数中，只能访问静态成员，不允许访问实例对象。

- 实例对象中，即可以使用静态成员，也可以使用实例成员。

### c sharp基本数据类型

1. 整型:byte、short、int、long 四种。
2. 浮点型:float、double 两种。
3. 字符型:char。
4. 布尔型:bool。
5. 复数型:complex。
6. 数组：指向整数或浮点数的指针 (int[]、double[] 等) 可以表示数组。
7. 结构体 (struct):一种特殊的数据类型，可以包含多个成员变量，其类型可以是整型、浮点型、字符型、布尔型等。
8. 枚举 (enum):一种用于表示一组预定义值的数据类型，可以使用命名常量来表示。
9. 委托 (delegate):一种用于表示函数指针的数据类型，可以用于传递函数对象。
10. 字符串 string

值类型:int，double，bool，char，decimal，struct，enum。存储在内存栈

引用：string，自定义类。存储在内存堆中

1. 值类型直接存储数据，而引用类型存储指向数据的引用。
2. 值类型的变量存储的是数据本身，而引用类型的变量存储的是数据的引用。
3. 引用类型是动态绑定的，而值类型是静态绑定的。
4. 值类型可以直接赋值给引用类型，而引用类型不能直接赋值给值类型。

例如，一个 string 类型的对象需要一个内存地址来存储，而一个 byte 类型的对象则直接存储数据本身。因此，当多个值类型共享相同的内存地址时，它们不会相互影响，而引用类型则会因为它们引用不同的对象而相互影响。

![image-20230427180457116](E:\typora\Csharpnote\img\image-20230427180457116.png)

对于应用类型它的值存储在堆上，在栈上只会存储他引用的

### 委托，lambda表达式和事件

#### 什么是委托?

​		C#中的委托(Delegate)是一种用于封装方法的类型,它可以看做是函数指针(Function Pointer) 的一种高级形式。委托是一种能够将方法作为参数传递、存储方法并且调用方法的类型，它可以让我们写出更加灵活和可扩展的代码。

​		委托通常用于回调 (Callback) 机制，比如在事件处理、异步编程、LINQ 查询等场景中常常会使用委托。它可以将方法作为参数传递给其他方法，从而在需要的时候执行该方法。

### 异步任务

C#中的异步任务(Asynchronous Task) 是一种通过异步方式执行任务的方式，它可以让程序在执行异步任务的时候暂停执行，转而执行其他任务，直到异步任务完成再继续执行。这种方式可以大幅提高程序的性能和响应速度，尤其是在处理大量 I/O 操作的时候。

下面是异步任务的详细介绍:

1. 异步任务的定义： 异步任务是一个委托 (delegate),该委托在执行时能够暂停或恢复执行，可以在执行异步任务的时候转而执行其他任务。异步任务可以使用 async/await 关键字来创建。
2. 异步任务的基本概念： 异步任务包含两个重要的概念:Task 和 async/await。

- Task 是一个类，它代表异步任务的执行结果。Task 类包含了异步任务的执行状态、进度、错误等信息。
- async/await是C#中用于创建异步任务的关键字,它可以让程序在执行异步任务的时候暂停执行,转而执行其他任务,直到异步任务完成再继续执行。

1. 异步任务的使用方式： 要使用异步任务，需要先使用 Task 类或 async/await 关键字创建一个异步任务，然后执行该异步任务。

- 使用 Task 类创建异步任务:Task task = new Task( delegate { /* 异步任务代码 */ });
- 使用async/await关键字创建异步任务:async Task<int> MyTask(int i) { await Task.Delay(1000); return i + 1; }
  int result = MyTask(10).Result;

1. 异步任务的优点： 异步任务可以大幅提高程序的性能和响应速度，尤其是在处理大量 I/O 操作的时候。使用异步任务可以让程序在执行异步任务的时候暂停执行，转而执行其他任务，直到异步任务完成再继续执行，这样可以避免阻塞主线程，提高程序的性能和响应速度。
2. 异步任务的应用场景： 异步任务可以用于处理网络请求、文件读写、数据库操作、UI 渲染等场景，可以在处理这些操作的时候提高程序的性能和响应速度。同时，异步任务也可以用于处理长时间的计算任务，例如排序、聚类等计算任务，可以避免阻塞主线程，提高程序的性能和响应速度。

### 反射

C#中的反射(Reflection)是一种机制,它允许程序在运行时获取、检查和修改对象的类型、属性、方法等信息,使得程序可以在运行时动态地创建、调用和处理对象。下面是反射的详细介绍:

1. 反射的定义： 反射是一种机制，它允许程序在运行时获取、检查和修改对象的类型、属性、方法等信息，使得程序可以在运行时动态地创建、调用和处理对象。
2. 反射的使用方式： 要使用反射，需要先使用 Assembly 类或 Type 类获取程序集中的类型信息，然后使用 object 类或 Type 类获取对象实例或类型信息。

- 获取程序集中的类型信息:Assembly assembly = Assembly.GetExecutingAssembly();
- 获取对象实例:object obj = Activator.CreateInstance(type);
- 获取类型信息:Type type = typeof(MyClass);

1. 反射的优点： 反射可以使得程序在运行时动态地创建、调用和处理对象，避免了编译时的类型检查和代码生成，提高了程序的灵活性和可扩展性。
2. 反射的应用场景： 反射可以用于创建对象实例、调用私有方法、获取类属性、检查对象类型等信息。

- 创建对象实例:object obj = Activator.CreateInstance(type);
- 调用私有方法:MethodInfo method = type.GetMethod("PrivateMethod");
- 获取类属性:PropertyInfo property = type.GetProperty("PropName");
- 检查对象类型:Type type = obj.GetType();

总之,反射是C#中非常强大的机制,它使得程序可以在运行时动态地创建、调用和处理对象,提高了程序的灵活性和可扩展性。在实际应用中,反射可以被用于创建动态的UI界面、动态生成代码等场景。

### 依赖注入

C#依赖注入(Dependency Injection，简称 DI) 是一种软件设计模式。它的基本概念是，不直接创建或使用对象，而是使用参数、构造函数或属性等来动态地分配责任。

在传统的程序设计中，通常使用构造函数或实例初始化器来创建对象。这样会导致代码的耦合度很高，一旦需要修改对象的属性或构造函数，就需要修改整个代码。而且，构造函数和方法的调用方式可能会造成代码难以理解和维护。

而依赖注入则通过将依赖关系交给容器来管理，容器负责创建对象并将它们连接起来，从而实现代码的松耦合。在依赖注入中，对象不再直接创建或使用其他对象，而是通过参数、属性或构造函数等来获取依赖对象。这种方式使得代码更加灵活、可扩展，并且易于维护。

依赖注入的实现方式有很多种，其中最常见的是 Autofac 和 Unity 等依赖注入容器。这些容器可以使用参数、属性、构造函数等方式来动态地分配依赖关系，并且可以方便地管理对象之间的依赖关系。使用依赖注入容器，可以让代码更加简单、易于维护，并且可以提高代码的可测试性和可维护性。